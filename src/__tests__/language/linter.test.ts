import { describe, expect, it } from "bun:test";

import {
  rangeFromMessage,
  getWarningMessage,
  getErrorMessage,
} from "../../language/linter";

// all messages actually generated by stanc
const jacobianWarning = `Warning in 'jacobian.stan', line 1, column 12: Variable name 'jacobian' will
    be a reserved word starting in Stan 2.38.0. Please rename it!
`;

// note: stanc can produce warnings like this that do not contain a position!
const emptyModelWarning = `Warning: Empty file 'empty.stan' detected; this is a valid stan model but
    likely unintended!`;

const multiColumnError = `Semantic error in 'multicol.stan', line 3, column 4 to column 10:
   -------------------------------------------------
     1:  parameters {
     2:      real y;
     3:      int x;
             ^
     4:  }
     5:  model {
   -------------------------------------------------

(Transformed) Parameters cannot be integers.
`;

const multiLineError = `Semantic error in 'multiline.stan', line 2, column 2 to line 4, column 16:
   -------------------------------------------------
     1:  generated quantities {
     2:    array[3] int x
           ^
     3:             =
     4:               10;
   -------------------------------------------------

Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int
`;

describe("Linting", () => {
  describe("position detection", () => {
    it("empty message returns undefined", () => {
      const message = "";
      const position = rangeFromMessage(message);
      expect(position).toBeUndefined();
    });

    it("message without position returns undefined", () => {
      const position = rangeFromMessage(emptyModelWarning);
      expect(position).toBeUndefined();
    });

    it("should detect the position of a single line, single column message", () => {
      const position = rangeFromMessage(jacobianWarning);
      expect(position).toBeDefined();
      expect(position?.start.line).toEqual(position!.end.line);
      expect(position?.start.character).toEqual(position!.end.character);

      expect(position?.start.line).toEqual(0);
      expect(position?.start.character).toEqual(12);
    });

    it("should detect the position of a single line, multi-column error", () => {
      const position = rangeFromMessage(multiColumnError);
      expect(position).toBeDefined();
      expect(position?.start.line).toEqual(position!.end.line);
      expect(position?.start.character).not.toEqual(position!.end.character);

      expect(position?.start.line).toEqual(2);
      expect(position?.start.character).toEqual(4);
      expect(position?.end.character).toEqual(10);
    });

    it("should detect the position of a multi-line, multi-column error", () => {
      const position = rangeFromMessage(multiLineError);
      expect(position).toBeDefined();
      expect(position?.start.line).not.toEqual(position?.end.line);
      expect(position?.start.character).not.toEqual(position?.end.character);

      expect(position?.start.line).toEqual(1);
      expect(position?.start.character).toEqual(2);
      expect(position?.end.line).toEqual(3);
      expect(position?.end.character).toEqual(16);
    });
  });

  describe("message extraction", () => {
    it("should extract warning message without position", () => {
      const warningMessage = getWarningMessage(jacobianWarning);
      expect(warningMessage).toEqual(
        "Variable name 'jacobian' will be a reserved word starting in Stan 2.38.0. Please rename it!"
      );
    });

    it("should extract error message without position or snippet", () => {
      const errorMessage = getErrorMessage(multiColumnError);
      expect(errorMessage).toEqual(
        "(Transformed) Parameters cannot be integers."
      );
    });

    it("should extract longer error message without position and snippet", () => {
      const errorMessage = getErrorMessage(multiLineError);
      expect(errorMessage).toEqual(
        `Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int`
      );
    });
  });
});
