import { describe, expect, it } from "bun:test";

import { provideDiagnostics } from "../../../language/diagnostics/provider";
import type { StancReturn } from "stanc3";

// all messages actually generated by stanc
const jacobianWarning = `Warning in 'jacobian.stan', line 1, column 12: Variable name 'jacobian' will
    be a reserved word starting in Stan 2.38.0. Please rename it!
`;

// note: stanc can produce warnings like this that do not contain a position!
const emptyModelWarning = `Warning: Empty file 'empty.stan' detected; this is a valid stan model but
    likely unintended!`;

const multiColumnError = `Semantic error in 'multicol.stan', line 3, column 4 to column 10:
   -------------------------------------------------
     1:  parameters {
     2:      real y;
     3:      int x;
             ^
     4:  }
     5:  model {
   -------------------------------------------------

(Transformed) Parameters cannot be integers.
`;

const multiLineError = `Semantic error in 'multiline.stan', line 2, column 2 to line 4, column 16:
   -------------------------------------------------
     1:  generated quantities {
     2:    array[3] int x
           ^
     3:             =
     4:               10;
   -------------------------------------------------

Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int
`;

describe("Diagnostics provider", () => {
  it("should return an empty list on compiler result without errors or warnings", () => {
    const compilerResult: StancReturn = { errors: undefined, result: "" }
    const diagnostics = provideDiagnostics(compilerResult);
    expect(diagnostics).toBeEmpty();
  });

  it("should return an empty list for warning without position", () => {
    const compilerResult: StancReturn = { errors: undefined, result: "", warnings: [emptyModelWarning] }
    const diagnostics = provideDiagnostics(compilerResult);
    expect(diagnostics).toBeEmpty();
  });

  it("should return warning diagnostics for a single line, single column warning message", () => {
    const compilerResult: StancReturn = { warnings: [jacobianWarning], result: "", errors: undefined }
    const diagnostics = provideDiagnostics(compilerResult);
    const expectedRange = {
      start: { line: 0, character: 12 },
      end: { line: 0, character: 12 }
    };
    const expectedMessage = "Variable name 'jacobian' will be a reserved word starting in Stan 2.38.0. Please rename it!"
    expect(diagnostics).not.toBeEmpty();
    expect(diagnostics[0]?.range).toBeDefined()
    expect(diagnostics[0]?.range).toEqual(expectedRange);
    expect(diagnostics[0]?.message).toEqual(expectedMessage);
  });

  it("should return error diagnostics for a multi-column error message", () => {
    const compilerResult: StancReturn = { errors: [multiColumnError], result: undefined }
    const diagnostics = provideDiagnostics(compilerResult);
    const expectedRange = {
      start: { line: 2, character: 4 },
      end: { line: 2, character: 10 }
    };
    const expectedMessage = "(Transformed) Parameters cannot be integers."
    expect(diagnostics).not.toBeEmpty();
    expect(diagnostics[0]?.severity).toEqual("error");
    expect(diagnostics[0]?.range).toEqual(expectedRange);
    expect(diagnostics[0]?.message).toEqual(expectedMessage);
  });

  it("should return error diagnostics for a multi-line, multi-column error message", () => {
    const compilerResult: StancReturn = { errors: [multiLineError], result: undefined }
    const diagnostics = provideDiagnostics(compilerResult);
    const expectedRange = {
      start: { line: 1, character: 2 },
      end: { line: 3, character: 16 }
    };
    const expectedMessage = `Ill-typed arguments supplied to assignment operator =:\nThe left hand side has type\n  array[] int\nand the right hand side has type\n  int`
    expect(diagnostics).not.toBeEmpty();
    expect(diagnostics[0]?.severity).toEqual("error");
    expect(diagnostics[0]?.range).toEqual(expectedRange);
    expect(diagnostics[0]?.message).toEqual(expectedMessage);
  });
});
